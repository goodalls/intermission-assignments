# Module 4 Intermission Assignments

## Filling Out Your Skill Set

1. If you're not familiar with the HTTP request-response cycle, then [watch this video](https://www.youtube.com/watch?v=eesqK59rhGA)
2. Read Eloquent JavaScript: [Chapter 17 - HTTP](http://eloquentjavascript.net/17_http.html) and [Chapter 20 - Node.js](http://eloquentjavascript.net/20_node.html)
3. Complete this [lesson on writing a Node HTTP server](http://frontend.turing.io/lessons/module-4/node-prework.html) - Walk through the lesson and code along; finish the functions `getAllMessages` and `addMessage` at the end of the lesson
4. Complete the [tutorial for writing an Express server](https://medium.com/@jaeger.rob/introduction-to-nodes-express-js-db5617047150) - In addition to going through the tutorial, work on 3 out of 4 of the problems in the "Further Challenges" section at the end of the tutorial
5. Read these things [about RESTful API design](https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9)
6. Read about and practice writing [Promises](https://gist.github.com/robbiejaeger/dc8f55c1f9462741090862f736b82cab)
7. Become familiar with the git rebase workflow (you will use this on projects in module 4). Read this article on [git rebase](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase) and this article on [merging vs. rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing).

*Note:* For some projects in module 4, you will have to use vanilla JS or jQuery (you will not be able to use React or other frameworks in the first project, for instance). So refresh your skills as needed.

## Scaling Up as a Developer

As we move into the final module of Turing, we're getting fairly competent at producing useful software. But rather than being the end of the journey, this really just opens the door to even deeper rabbit holesâ€”now that I can get something done, what other ways might there be to accomplish the same thing? The same observable effects could be accomplished via numerous different combinations of code. What are the underlying opinions and ideas embodied by each choice?

Here are are a couple "philosophical" materials to hopefully help us contemplate this side of the issue:

* [Simplicity Matters by Rich Hickey](https://www.youtube.com/watch?v=rI8tNMsozo0) - As we move into working on larger and more sophisticated systems, some of the approaches that have worked on smaller projects may no longer be so effective. What does Rich Hickey say about the common pitfalls of web applications?
* [Real Software Engineering by Glenn Vanderburg](https://www.youtube.com/watch?v=NP9AIUT9nos) - What does Glenn have to say about Software Engineering as a discipline? How does Software Engineering differ fundamentally from other engineering disciplines? What can we as Software Engineers take away from other disciplines?
